<html>
    <head>
        <meta charset="utf-8">
        <title>magnet</title>
        <style>
            body {
                color: #61443e;
                font-family:Monospace;
                font-size:13px;
                text-align:center;

                background-color: #bfd1e5;
                margin: 0px;
                overflow: hidden;
            }
			#speedometer {
				color: #ffffff;
				background-color: #990000;
				position: absolute;
				bottom: 0px;
				padding: 5px;
			}
            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }

            a {

                color: #a06851;
            }
        </style>
    </head>
    <body>
        <div id="info">Floating Magnet Sandbox<br>Press a to shoot magnet<br>Press d to set drag, p to set density, b to set buoyancy, w to set water level<br> Current Variable:  <p id='variable'></p><p id='amt'></p><br>Press ,. to scale</div>
        
        <script src="js/three.js"></script>
        <script src="js/ammo.js"></script>
        <script src="utils.js"></script>
        <script type="module">

            import { Water } from '../../../js/water2.mjs';

            //variable declaration section
            let physicsWorld, scene, camera, clock, renderer, water, rigidBodies = [], tmpTrans = null //for physics world, rigid bodies
            let radius = 100, onMouseDownPosition, theta = 0, onMouseDownTheta = 45, phi = 73.3, onMouseDownPhi = 60 //for water
            let controlObject = null,
            kMoveDirection = { left: 0, right: 0, forward: 0, back: 0 } //moving magball
            let prevColor;
            let magnet = [];
            let positiveMagnet = [];
            let negativeMagnet = [];
            let metallic = [];
            let walls = []
            let waterDirection = 0;
            //constants
            let waterlevel;
            let gravity = 20;
            let densityConstant = 1;
            let magnetConstant = 100;
            let buoyancyConstant = 0.1;
            let dragConstant = 0.2;
            let currentSwitch; //depending on currentSwitch, ,. key will change the constants
            let constantChange = 0;
            let white = new THREE.Color( 0xffffff );

            let mousedown = false;
            const FLAGS = { CF_KINEMATIC_OBJECT: 2}
            var params = {
				color: '#ffffff',
				scale: 4,
				flowX: 1,
				flowY: 1
			};

            const STATE = { DISABLE_DEACTIVATION : 4}

            let ammoTmpPos = null, ammoTmpQuat = null;

            //Ammojs Initialization
            Ammo().then(start)

            function start (){

                tmpTrans = new Ammo.btTransform();
                ammoTmpPos = new Ammo.btVector3();
                ammoTmpQuat = new Ammo.btQuaternion();

                setupPhysicsWorld();

                setupGraphics();
                createWater();
                createBlock(0,0,0,100,2,100);
                createInvisibleWall(0,(waterlevel + 5) / 2,-50,102,waterlevel + 5,2);
                createInvisibleWall(0,(waterlevel + 5) / 2, 50,102,waterlevel + 5,2);
                createInvisibleWall(50,(waterlevel + 5) / 2,0,2,waterlevel + 5,102);
                createInvisibleWall(-50,(waterlevel + 5) / 2,0,2,waterlevel + 5,102);
                createBlock();
                createMagnetBar(0,0,0);
                createPositiveMagnetBall(20, 20);
                createPositiveMagnetBall(-20, -20);
                createNegativeMagnetBall(20, -20);
                createNegativeMagnetBall(-20, 20);
                // createTorus(0,0);

                setupEventHandlers();
                renderFrame();

                onMouseDownPosition = new THREE.Vector2();

            }

            function setupPhysicsWorld(){

                let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                    dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
                    overlappingPairCache    = new Ammo.btDbvtBroadphase(),
                    solver                  = new Ammo.btSequentialImpulseConstraintSolver();

                physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -gravity, 0));

                waterlevel = 20;

            }


            function setupGraphics(){

                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xbfd1e5 );

                //create camera
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 5000 );
                camera.position.set( 0, 60, 80 );
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                var ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.6 );
				directionalLight.position.set( - 1, 1, 1 );
				scene.add( directionalLight );

                //Add directional light
                let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                scene.add( dirLight );

                dirLight.castShadow = true;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                let d = 50;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;

                //Setup the renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;

                renderer.shadowMap.enabled = true;

            }


            function renderFrame(){

                let deltaTime = clock.getDelta();

                moveMagBall();
                
                updateWaterlevel( deltaTime );

                updatePhysics( deltaTime );

                updateConstants( deltaTime );

                renderer.render( scene, camera );

                requestAnimationFrame( renderFrame );

            }

            function setupEventHandlers(){

                window.addEventListener( 'keydown', handleKeyDown, false);
                window.addEventListener( 'keyup', handleKeyUp, false);
                window.addEventListener( 'mousedown', handleMouseDown, false);
                window.addEventListener( 'mouseup', handleMouseUp, false);
                window.addEventListener( 'mousemove', handleMouseMove, false);
                window.addEventListener( 'wheel', handleWheel, false);

            }


            function handleKeyDown(event){

                let keyCode = event.keyCode;

                switch(keyCode){
                    case 38: //↑: FORWARD
                        kMoveDirection.forward = 1
                        break;
                        
                    case 40: //↓: BACK
                        kMoveDirection.back = 1
                        break;
                        
                    case 37: //←: LEFT
                        kMoveDirection.left = 1
                        break;
                        
                    case 39: //→: RIGHT
                        kMoveDirection.right = 1
                        break;

                    case 87: //W -> water level up
                        currentSwitch = 0;
                        break;

                    case 80: //change curswitch to density = 1; p key
                        currentSwitch = 1;
                        break;
                    
                    case 77: //curswitch to mag = 2; m key
                        currentSwitch = 2;
                        break;
                    
                    case 66: //to buo = 3; b key
                        currentSwitch = 3;
                        break;
                    
                    case 68: //drag = 4; d key
                        currentSwitch = 4;
                        break;

                    case 188: //decrease constant; , key
                        constantChange = -1;
                        break;

                    case 190: //increase constant; . key
                        constantChange = 1;
                        break;

                    // case 83: //shoot ball: s key
                    //     shootBall(0);
                    //     break;

                    case 65: //shoot magnet bar a key
                        shootMagnetBar();
                        break;
                }
            }


            function handleKeyUp(event){
                let keyCode = event.keyCode;

                switch(keyCode){
                    case 38: //↑: FORWARD
                        kMoveDirection.forward = 0
                        break;
                    
                    case 40: //↓: BACK
                        kMoveDirection.back = 0
                        break;
                    
                    case 37: //←: LEFT
                        kMoveDirection.left = 0
                        break;
                    
                    case 39: //→: RIGHT
                        kMoveDirection.right = 0
                        break;

                    case 188: //decrease constant; , key
                        constantChange = 0;
                        break;

                    case 190: //increase constant; . key
                        constantChange = 0;
                        break;

                }

            }

            function handleMouseDown( event ){
                mousedown = true;
                event.preventDefault();

				onMouseDownTheta = theta;
				onMouseDownPhi = phi;
				onMouseDownPosition.x = event.clientX;
                onMouseDownPosition.y = event.clientY;

                let mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
                                    0.5 );  
                
                let raycaster = new THREE.Raycaster();
                raycaster.setFromCamera( mouse3D, camera);
                let intersects = raycaster.intersectObjects( rigidBodies );
                if ( intersects.length > 0 ) {
                    if (prevColor) {
                        controlObject.material.color.setHex( prevColor );
                    }
                    controlObject = intersects[ 0 ].object;
                    prevColor = controlObject.material.color.getHex();
                    controlObject.material.color.lerp(white, 0.3);
                }

            }

            function handleMouseUp( event ){
                mousedown = false;
                event.preventDefault();

				onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
				onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;
            }
            
            function handleMouseMove( event ){

                event.preventDefault();

                if ( mousedown ) {

                    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 )
                            + onMouseDownTheta;
                    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 )
                        + onMouseDownPhi;

                    phi = Math.min( 180, Math.max( 0, phi ) );

                    camera.position.x = radius * Math.sin( theta * Math.PI / 360 )
                                        * Math.cos( phi * Math.PI / 360 );
                    camera.position.y = radius * Math.sin( phi * Math.PI / 360 );
                    camera.position.z = radius * Math.cos( theta * Math.PI / 360 )
                                        * Math.cos( phi * Math.PI / 360 );
                    camera.updateMatrix();
                    camera.lookAt(new THREE.Vector3(0, 0, 0));

                }
            }

            function handleWheel( event ){

                camera.zoom = camera.zoom - event.deltaY * 0.001
                camera.updateProjectionMatrix ()

            }


            function createWater(){
                
                var waterGeometry = new THREE.PlaneBufferGeometry( 100, 100, 0 );

				water = new Water( waterGeometry, {
					color: params.color,
					scale: params.scale,
					flowDirection: new THREE.Vector2( params.flowX, params.flowY ),
					textureWidth: 1024,
					textureHeight: 1024
				} );

				water.position.y = waterlevel;
				water.rotation.x = Math.PI * - 0.5;
				scene.add( water );
            }

            function createBlock( posx, posy, posz, scx, scy, scz){
                
                let pos = {x: posx, y: posy, z: posz};
                let scale = {x: scx, y: scy, z: scz};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 0;

                //threeJS Section
                let blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshLambertMaterial({color: 0xa38149}));

                blockPlane.position.set(pos.x, pos.y, pos.z);
                blockPlane.scale.set(scale.x, scale.y, scale.z);

                blockPlane.castShadow = true;
                blockPlane.receiveShadow = true;

                scene.add(blockPlane);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );

                body.setFriction(4);
                body.setRollingFriction(10);

                physicsWorld.addRigidBody( body);
            }

            function createInvisibleWall( posx, posy, posz, scx, scy, scz){
                
                let pos = {x: posx, y: posy, z: posz};
                let scale = {x: scx, y: scy, z: scz};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 0;

                // threeJS Section
                let blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa38149}));

                blockPlane.position.set(pos.x, pos.y, pos.z);
                blockPlane.scale.set(scale.x, scale.y, scale.z);

                blockPlane.castShadow = true;
                blockPlane.receiveShadow = true;

                scene.add(blockPlane);


                // Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 100, scale.z * 0.5 ) );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );

                body.setFriction(4);
                body.setRollingFriction(10);


                walls.push(blockPlane);
                physicsWorld.addRigidBody( body);
            }

            function createPositiveMagnetBall( xPos, zPos){
                
                let pos = {x: xPos, y: 4, z: zPos};
                let radius = 2;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0xee1111}));

                ball.position.set(pos.x, pos.y, pos.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );

                body.setFriction(3);
                body.setRollingFriction(3);
                body.setActivationState( STATE.DISABLE_DEACTIVATION );


                physicsWorld.addRigidBody( body);

                ball.userData.physicsBody = body;
                ball.userData.density = 1;
                rigidBodies.push(ball);
                magnet.push(ball);
                positiveMagnet.push(ball);
            }

            function createTorus( xPos, zPos){
                
                let pos = {x: xPos, y: 4, z: zPos};
                let radius = 2;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                let ball = new THREE.Mesh(new THREE.TorusKnotGeometry(5,2,100,16), new THREE.MeshNormalMaterial({color: 0xee1111}));

                ball.position.set(pos.x, pos.y, pos.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );

                body.setFriction(3);
                body.setRollingFriction(3);
                body.setActivationState( STATE.DISABLE_DEACTIVATION );


                physicsWorld.addRigidBody( body);

                ball.userData.physicsBody = body;
                ball.userData.density = 200;
                rigidBodies.push(ball);
            }

            function createNegativeMagnetBall( xPos, zPos ){
                
                let pos = {x: xPos, y: 4, z: zPos};
                let radius = 2;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0x1111ee}));

                ball.position.set(pos.x, pos.y, pos.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );

                body.setFriction(3);
                body.setRollingFriction(3);
                body.setActivationState( STATE.DISABLE_DEACTIVATION );


                physicsWorld.addRigidBody( body);

                ball.userData.physicsBody = body;
                ball.userData.density = 1;
                rigidBodies.push(ball);
                magnet.push(ball);
                negativeMagnet.push(ball);
            }

            function createMagnetBar( posx, posy, posz ){

                let pos = {x: posx, y: posy, z: posz};
                let scale = {x: 15, y: 0.7, z: 4};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;
                let radius = 1;


                let block = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xf78a1d}));

                block.position.set(posx, posy + 4, posz);
                block.scale.set(scale.x,scale.y,scale.z);

                block.castShadow = true;
                block.receiveShadow = true;

                scene.add(block);


                //Block Physics
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( posx, posy + 4, posz ) );
                transform.setRotation( new Ammo.btQuaternion( 0,0,0,1 ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let blockColShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
                blockColShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                blockColShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, blockColShape, localInertia );
                let blockBody = new Ammo.btRigidBody( rbInfo );

                
                blockBody.setActivationState( STATE.DISABLE_DEACTIVATION );
                physicsWorld.addRigidBody( blockBody);
                blockBody.setLinearVelocity(new Ammo.btVector3(0,0,0));
                
                block.userData.physicsBody = blockBody;
                block.userData.density = 0.05;
                rigidBodies.push(block);


                // Sphere Graphics
                let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0xee1111}));

                ball.position.set(pos.x + 6, pos.y + 4, pos.z);

                ball.castShadow = true;
                ball.receiveShadow = true;

                //scene.add(ball);

                //Sphere Physics
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x + 6, pos.y + 4, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( 0,0,0,1 ) );
                motionState = new Ammo.btDefaultMotionState( transform );

                let sphereColShape = new Ammo.btSphereShape( radius );
                sphereColShape.setMargin( 0.05 );

                localInertia = new Ammo.btVector3( 0, 0, 0 );
                sphereColShape.calculateLocalInertia( mass, localInertia );

                rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, sphereColShape, localInertia );
                let sphereBody = new Ammo.btRigidBody( rbInfo );

                physicsWorld.addRigidBody( sphereBody);

                ball.userData.physicsBody = sphereBody;
                ball.userData.density = 0.1;
                rigidBodies.push(ball);
                positiveMagnet.push(ball);

                //Sphere2 Graphics
                let ball2 = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0x000055}));

                ball2.position.set(pos.x - 6, pos.y + 4, pos.z);

                ball2.castShadow = true;
                ball2.receiveShadow = true;

                //scene.add(ball2);

                //Sphere2 Physics
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x - 6, pos.y + 4, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( 0,0,0,1 ) );
                motionState = new Ammo.btDefaultMotionState( transform );

                let sphereColShape2 = new Ammo.btSphereShape( radius );
                sphereColShape2.setMargin( 0.05 );

                localInertia = new Ammo.btVector3( 0, 0, 0 );
                sphereColShape2.calculateLocalInertia( mass, localInertia );

                rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, sphereColShape2, localInertia );
                let sphereBody2 = new Ammo.btRigidBody( rbInfo );

                physicsWorld.addRigidBody( sphereBody2);

                ball2.userData.physicsBody = sphereBody2;
                ball2.userData.density = 0.1;
                rigidBodies.push(ball2);
                negativeMagnet.push(ball2);

                //sphere3
                let ball3 = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0xdddddd}));

                ball3.position.set(pos.x - 6, pos.y + 4, pos.z + 1);

                ball3.castShadow = true;
                ball3.receiveShadow = true;

                //scene.add(ball3);

                //Sphere3 Physics
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y + 4, pos.z + 1 ) );
                transform.setRotation( new Ammo.btQuaternion( 0,0,0,1 ) );
                motionState = new Ammo.btDefaultMotionState( transform );

                let sphereColShape3 = new Ammo.btSphereShape( radius );
                sphereColShape3.setMargin( 0.05 );

                localInertia = new Ammo.btVector3( 0, 0, 0 );
                sphereColShape3.calculateLocalInertia( mass, localInertia );

                rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, sphereColShape2, localInertia );
                let sphereBody3 = new Ammo.btRigidBody( rbInfo );

                physicsWorld.addRigidBody( sphereBody3);

                ball3.userData.physicsBody = sphereBody3;
                ball3.userData.density = 0.1;
                rigidBodies.push(ball3);

                //sphere4
                let ball4 = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0x111111}));

                ball4.position.set(pos.x, pos.y + 4, pos.z - 1);

                ball4.castShadow = true;
                ball4.receiveShadow = true;

                //scene.add(ball4);

                //Sphere4 Physics
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y + 4, pos.z - 1 ) );
                transform.setRotation( new Ammo.btQuaternion( 0,0,0,1 ) );
                motionState = new Ammo.btDefaultMotionState( transform );

                let sphereColShape4 = new Ammo.btSphereShape( radius );
                sphereColShape4.setMargin( 0.05 );

                localInertia = new Ammo.btVector3( 0, 0, 0 );
                sphereColShape4.calculateLocalInertia( mass, localInertia );

                rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, sphereColShape4, localInertia );
                let sphereBody4 = new Ammo.btRigidBody( rbInfo );

                physicsWorld.addRigidBody( sphereBody4);

                ball4.userData.physicsBody = sphereBody4;
                ball4.userData.density = 0.1;
                rigidBodies.push(ball4);

                //Create Joints
                let spherePivot = new Ammo.btVector3( 0, 0, 0 );
                let blockPivot = new Ammo.btVector3( 6, 0, 0 );
                let blockPivot2 = new Ammo.btVector3(-6,0,0);
                let blockPivot3 = new Ammo.btVector3(0,0,1);
                let blockPivot4 = new Ammo.btVector3(0,0,-1);
                let p2p = new Ammo.btPoint2PointConstraint( sphereBody, blockBody, spherePivot, blockPivot);
                physicsWorld.addConstraint( p2p, true );
                let p2p2 = new Ammo.btPoint2PointConstraint( sphereBody2, blockBody, spherePivot, blockPivot2);
                physicsWorld.addConstraint( p2p2, true );
                let p2p3 = new Ammo.btPoint2PointConstraint( sphereBody3, blockBody, spherePivot, blockPivot3);
                physicsWorld.addConstraint( p2p3, true );
                let p2p4 = new Ammo.btPoint2PointConstraint( sphereBody4, blockBody, spherePivot, blockPivot4);
                physicsWorld.addConstraint( p2p4, true );

                return block;


            }

            function shootBall(type){
                //types: 0: none, 1: metallic, 2: negative magnet, 3: positive magnet
                let copycamerapos = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
                copycamerapos.setLength(50);
                let pos = {x: copycamerapos.x, y: copycamerapos.y, z: copycamerapos.z};
                let radius = 2;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                let ball = new THREE.Mesh(new THREE.SphereBufferGeometry(radius), new THREE.MeshPhongMaterial({color: 0x0505ff}));

                ball.position.set(pos.x, pos.y, pos.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );

                body.setFriction(3);
                body.setRollingFriction(3);
                body.setActivationState( STATE.DISABLE_DEACTIVATION );
                body.setLinearVelocity(new Ammo.btVector3(-copycamerapos.x / 2, 20, -copycamerapos.z / 2));


                physicsWorld.addRigidBody( body);

                ball.userData.physicsBody = body;
                rigidBodies.push(ball);
                magnet.push(ball);
                // negativeMagnet.push(ball);
            }

            function shootMagnetBar(){
                let copycamerapos = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
                copycamerapos.setLength(50);
                let bar = createMagnetBar(copycamerapos.x, copycamerapos.y, copycamerapos.z);
                bar.userData.physicsBody.setLinearVelocity(new Ammo.btVector3(-copycamerapos.x / 2, 20, -copycamerapos.z / 2));
            }

            function moveMagBall(){

                if (!controlObject){
                    return;
                }

                let scalingFactor = 2;

                let moveX =  kMoveDirection.right - kMoveDirection.left;
                let moveZ =  kMoveDirection.back - kMoveDirection.forward;
                let moveY =  0; 

                if( moveX == 0 && moveY == 0 && moveZ == 0) return;

                let physicsBody = controlObject.userData.physicsBody;
                let vel = physicsBody.getLinearVelocity();

                let resultantImpulse = new Ammo.btVector3( moveX, moveY, moveZ )
                resultantImpulse.op_mul(scalingFactor);
                physicsBody.setLinearVelocity( resultantImpulse.op_add(vel) );

            }

            function updateWaterlevel( deltaTime ){

                waterlevel += waterDirection * 10 * deltaTime;
                water.position.y = waterlevel;
                for (let i = 0; i < walls.length; i++){
                    let curscale = walls[i].scale;
                    curscale.set(curscale.x, waterlevel + 5, curscale.z);
                    let curpos = walls[i].position;
                    curpos.set(curpos.x, (waterlevel+5) / 2, curpos.z);
                }

            }

            function updateConstants( deltaTime){
                switch( currentSwitch ){

                    case 0:
                        document.getElementById('variable').innerHTML = "water level"
                        document.getElementById('amt').innerHTML = waterlevel
                        waterDirection = constantChange;
                        break;

                    case 1: //density
                        document.getElementById('variable').innerHTML = "density multiplier"
                        document.getElementById('amt').innerHTML = densityConstant
                        densityConstant += constantChange * 1 * deltaTime;
                        if (densityConstant < 0) {
                            densityConstant = 0;
                        }
                        break;
                    
                    case 2: //magnet
                        document.getElementById('variable').innerHTML = "magnet constant"
                        document.getElementById('amt').innerHTML = magnetConstant
                        magnetConstant += constantChange * 100 * deltaTime;
                        if (magnetConstant < 0) {
                            magnetConstant = 0;
                        }
                        if (magnetConstant > 150) {
                            magnetConstant = 150;
                        }
                        break;

                    case 3: //buo
                        document.getElementById('variable').innerHTML = "buoyancy constant"
                        document.getElementById('amt').innerHTML = buoyancyConstant
                        buoyancyConstant += constantChange * 0.1 * deltaTime;
                        if (buoyancyConstant < 0) {
                            buoyancyConstant = 0;
                        }
                        break;

                    case 4: //drag
                        document.getElementById('variable').innerHTML = "drag constant"
                        document.getElementById('amt').innerHTML = dragConstant
                        dragConstant += constantChange * 0.01 * deltaTime;
                        if (dragConstant < 0) {
                            dragConstant = 0;
                        }
                        break;

                }
            }

            function updateBodyMagnet( curbody ){

                for ( let i = 0; i < magnet.length; i++) {
                    applyMagnetic(curbody, magnet[i], -1);
                }
            }

            function updateInterMagnetic() {

                for ( let i = 0; i < positiveMagnet.length; i++) {
                    for ( let j = 0; j < positiveMagnet.length; j++) {
                        if (i == j) {
                            continue;
                        }
                        applyMagnetic(positiveMagnet[i], positiveMagnet[j], 1);
                    }
                    for ( let j = 0; j < negativeMagnet.length; j++) {
                        applyMagnetic(positiveMagnet[i], negativeMagnet[j], -1);
                    }
                }
                for ( let i = 0; i < negativeMagnet.length; i++) {
                    for ( let j = 0; j < negativeMagnet.length; j++) {
                        if (i == j) {
                            continue;
                        }
                        applyMagnetic(negativeMagnet[i], negativeMagnet[j], 1);
                    }
                }
            }


            //-1 is attraction, 1 is repulsion
            function applyMagnetic(curbody, curmagnet, dir) {
                let bodyToMag = new Ammo.btVector3((curmagnet.position.x - curbody.position.x),
                (curmagnet.position.y - curbody.position.y),
                (curmagnet.position.z - curbody.position.z));
                let distance = bodyToMag.length();
                if (distance == 0) {
                    return;
                }
                bodyToMag.op_mul(1/bodyToMag.length());
                let vel = curbody.userData.physicsBody.getLinearVelocity();
                let magVel = curmagnet.userData.physicsBody.getLinearVelocity();
                let magnitude = magnetConstant / distance / distance; //100 here needs to be scaled by mass. need update
                let newvel = new Ammo.btVector3( vel.x() + bodyToMag.x() * -dir * magnitude,
                    vel.y() + bodyToMag.y() * -dir * magnitude,
                    vel.z() + bodyToMag.z() * -dir * magnitude );
                let newMagVel = new Ammo.btVector3( magVel.x() + bodyToMag.x() * dir * magnitude,
                    magVel.y() + bodyToMag.y() * dir * magnitude,
                    magVel.z() + bodyToMag.z() * dir * magnitude );
                curbody.userData.physicsBody.setLinearVelocity(newvel);
                curmagnet.userData.physicsBody.setLinearVelocity(newMagVel);
            }

            //ill make box version and sphere version but for now everything sphere
            function calculateVolUnder( curbody ) {
                let rr = curbody.geometry.boundingSphere;
                if ( rr == null) {
                    return 0;
                }
                let r = rr.radius;
                let h = curbody.position.y + r - waterlevel;
                let caseval = curbody.position.y - waterlevel;
                let sphereVol = 4 / 3 * Math.PI * Math.pow( r, 3 );
                if ( -caseval > r ){
                    return sphereVol;
                }
                if ( caseval > r ){
                    return 0;
                }
                let capVol = volCap( r, Math.abs( h ) );
                return sphereVol - capVol;
            }
            
            function calculateRatioUnder( curbody ){
                let rr = curbody.geometry.boundingSphere;
                if ( rr == null) {
                    return 0;
                }
                let r = rr.radius;
                let h = curbody.position.y + r - waterlevel;
                let caseval = curbody.position.y - waterlevel;
                let sphereVol = 4 / 3 * Math.PI * Math.pow( r, 3 );
                if ( -caseval > r ){
                    return 1;
                }
                if ( caseval > r ){
                    return 0;
                }
                let capVol = volCap( r, Math.abs( h ) );
                return (sphereVol - capVol) / sphereVol;
            }

            function applyBuo( deltaTime ){
                for ( let i = 0; i < rigidBodies.length; i++ ){
                    let p = 1; //p is density. need update.
                    let body = rigidBodies[ i ].userData.physicsBody;
                    let density = rigidBodies[i].userData.density;
                    let vel = body.getLinearVelocity();
                    let ratioUnder = calculateRatioUnder( rigidBodies[ i ] );
                    let buo = densityConstant * buoyancyConstant * gravity * calculateVolUnder( rigidBodies[ i ] ) / density;
                    let dampenfactor = dragConstant * p / 2 * ratioUnder;
                    let dampenx = dampenfactor * Math.pow(vel.x(), 2);
                    let dampeny = dampenfactor * Math.pow(vel.y(), 2);
                    let dampenz = dampenfactor * Math.pow(vel.z(), 2);
                    // let dampenx = ratioUnder;
                    // let dampenz = ratioUnder;
                    let a = rigidBodies[ i ].position.y > waterlevel && vel.y() > 0;
                    let b = rigidBodies[ i ].position.y < waterlevel && vel.y() < 0;
                    if ( vel.x() < 0 ){
                        dampenx = -dampenx;
                    }
                    if ( vel.y() < 0 ){
                        dampeny = -dampeny;
                    }
                    if ( vel.z() < 0 ){
                        dampenz = -dampenz;
                    }
                    if (ratioUnder > 0){
                            let newvel = new Ammo.btVector3( vel.x() - dampenx,
                            (vel.y() + (buo - dampeny * 40 * ratioUnder) * deltaTime),
                            vel.z() - dampenz);
                            body.setLinearVelocity(newvel);
                            continue;
                    }
                    let newvel = new Ammo.btVector3( vel.x() - dampenx,
                    vel.y() + (buo - dampeny) * deltaTime,
                    vel.z() - dampenz * deltaTime); //also need area, update p to be density
                    body.setLinearVelocity(newvel);
                }
            }


            function updatePhysics( deltaTime ){

                // Step world
                physicsWorld.stepSimulation( deltaTime, 10 );
                for ( let i = 0; i < metallic.length; i++ ){
                    updateBodyMagnet(metallic[ i ]);
                }
                updateInterMagnetic();
                applyBuo( deltaTime );

                // Update rigid bodies
                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();
                    if ( ms ) {

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    }
                }

            }
        </script>
    </body>
</html>